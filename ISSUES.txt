Issues:


RPC/bitcoind Module missing

We can't actually publish transactions, check the current contract published state, verify the incoming tx output is actually unspent, etc.
The publishing side is only an inconvenience, but the inability to list our currently available strategies and actually validate that participants aren't just pretending their input is unspent is an issue.


Strategy logic missing

AS it stands, the client is able to ask for signatures, generate our own and serve them if asked, and put them together into a serialized transaction that it writes to console.
None of the logic that ties the contract steps to individual transaction is part of this process. It's possible this is out of scope of this part of the code, and it can be assumed to be offloaded to whoever uses the client.


Some hardcoded stuff (especially timeouts and testnet)


Conservative segwit converter

To avoid breaking txid references or PubkeyScript-SigScript validity, any TX input referencing a transaction outside our contract isn't changed.
This breaks the flow anyway when someone assembles a non-segwit tranasction and changes the txid hash inside the contract.
There is no easy way to solve this while preserving the original transaction structure. If we trust the participant that assembled it, a series of different malleability issues arise:
- The only way to propagate the expected txid change on every other participant is to trust that the tx author is giving us the correct old->new txid pair
- Even if we ask the author to send us the complete tx and we verify its signature and compute the new txid ourselves, we still have no guarantee it's been published like that on the net.
The balzac compiler only allows P2PKH and P2SH for input types, so putting a requirement of every entry tx only having segwit inputs isn't feasible.
None of this is a problem in coinbase transactions, since they don't actaully have an external input, so at least for proof of concept the system is still usable.

A practical solution to all the above would be to include in the original contract "bridge" transactions for each non-segwit entry transactions:
- The serialized tx data is a fully complete transaction that takes the P2PKH/P2SH input and has one P2WPKH/P2WSH output.
- Its metadata is present, but completely empty.
- It's already been published on the blockchain, and can be verified to be unspent.
This way, we have all input txids set in stone and documented in the contract state.
The segwit converter will just skip the already filled in non-segwit inputs (since its info has no ChunkEntry blocks),
and recognize as already compliant the segwit pubkeyscript-sigscript pair between the bridge and the actual first tx.


Predictable but unreliable public state JSON generation

The public state passed as JSON into the client during node setup has to be generated by the existing bitml toolchain: the signature computing and exchange side has no knwoledge of the original
bitml text, the balzac intermediate result, nor the balzac compile process.

Practically speaking, to programmatically generate the necessary json state we have a few steps throughout the toolchain that have to contribute their own info:
- The participant list is easy to infer from inside the bitml specific, or the intermediate balzac result.
  - The endpoint data can't be specified in either place currently (language extension or external data import?)
- The serialized, blank transactions can only be received as the final result of the balzac compile.
- The knowledge of which empty chunk should be filled with which information is only available inside the balzac parsing and compilation process.
- The knowledge of which strategy step corresponds to which sequence of transactions is only available in the bitml to balzac compilation.
The last is not necessary to the purely computational side: The client will try to complete any individual transaction it's asked to, and the onus of stringing together the right sequence can be left to the caller.
The first 3 however are necessary to create the JSON that drives the entire system, and can only be reliably generated if each toolchain step outputs the information themselves.
What this means is we will most likely have to either:
- Modify the existing compilers to output the additional info (I still have no idea how balzac's works)
- Roll our own multi-stage compiler following both languages' specs (what could possibly go wrong)

The signature exchange client is only able to sanity check a limited amount of this information:
- It will verify that our identity corresponds to one of the participants (not fatal: anyone can "spectate" the network state and send/receive messages from individual nodes).
- It will validate part of the endpoint configuration with the JSON-specified endpoint corresponding to ourselves (not fatal: there are many valid routing configurations that would trigger a false positive).
The logging system will keep track of who asked us what, how signatures are received, validated and saved, and many other network operations. (but the network model is async and not expected to receive an explicit ACK).


Limited non-signature chunk support

At the moment, the client does not allow to manually fill in secrets or any other chunk data that's not signatures.
If it's deemed necessary, extending it to allow this type of manipulation should be fairly straightforward but it would open a series of issues on manual input and data types with ints, strings and bytevectors.
In lieu of implementing such behaviour, the secrets can be inserted into the state from the JSON itself. However, any participant that asks for a transaction's chunks would also receive any secrets in that transaction.
The "secrets" branch implements a serializer that strips any secret chunk from its value when broadcasted; the client will not disclose any secret that's already part of its state.
It will still accept any secrets deliberately included into other nodes' messages.
